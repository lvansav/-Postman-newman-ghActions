{
	"info": {
		"_postman_id": "5e2743e6-93c7-41ce-9eaa-f008603a0091",
		"name": "store",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "23196865"
	},
	"item": [
		{
			"name": "Basic requests",
			"item": [
				{
					"name": "Products",
					"item": [
						{
							"name": "List products",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response time is less than 200ms\", function () {\r",
											"    pm.expect(pm.response.responseTime).to.be.below(200);\r",
											"});\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"pm.test(\"Content-Type is present\", function () {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get product by ID",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products/3",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products",
										"3"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create product",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"orange\",\r\n    \"price\": 8,\r\n    \"sku\": 123321123,\r\n    \"description\": \"wouh\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update product",
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"id\": 4,\r\n    \"name\": \"banana\",\r\n    \"price\": 155,\r\n    \"sku\": 123321123,\r\n    \"description\": \"changed description\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove product by ID",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products/4",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products",
										"4"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Orders",
					"item": [
						{
							"name": "List orders",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get order by ID",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/orders/3",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders",
										"3"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create order",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"order5\",\r\n    \"sku\": 123425445656765\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update order",
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"id\": 4,\r\n    \"name\": \"order5\",\r\n    \"sku\": 123425445656765\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove order by ID",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/orders/4",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders",
										"4"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Users",
					"item": [
						{
							"name": "List users",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get user by ID",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users/3",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users",
										"3"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create user",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"Dream\",\r\n    \"lastName\": \"Real\",\r\n    \"email\": \"dream.real@gmail.com\",\r\n    \"dateOfBirth\": \"2001-10-99\",\r\n    \"emailVerified\": true,\r\n    \"signUpDate\": \"2019-08-24\",\r\n    \"status\": \"active\",\r\n    \"level\": \"lord\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update user",
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"Ilon\",\r\n    \"lastName\": \"Mask\",\r\n    \"email\": \"ilon.mask@gmail.com\",\r\n    \"dateOfBirth\": \"2001-10-99\",\r\n    \"emailVerified\": true,\r\n    \"signUpDate\": \"2019-08-24\",\r\n    \"status\": \"active\",\r\n    \"level\": \"lord\",\r\n    \"id\": 10\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove user by ID",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users/10",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users",
										"10"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Folder with tests",
			"item": [
				{
					"name": "Integration tests",
					"item": [
						{
							"name": "Products flow",
							"item": [
								{
									"name": "List all products",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"prodCount\", allProducts.length)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create new product with random properties",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"addedProductId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"addedProduct\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								},
								{
									"name": "Get information about new product",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"const respProd = JSON.stringify(pm.response.json())\r",
													"const addedProd = pm.collectionVariables.get(\"addedProduct\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should be the created product\", () => {\r",
													"    pm.expect(addedProd).to.eql(respProd, \"Responce product is not added product\")\r",
													"})\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{addedProductId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{addedProductId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "List all products after adding new product",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const addedProduct = JSON.parse(pm.collectionVariables.get(\"addedProduct\"))\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of products\", () => {\r",
													"    pm.expect(allProducts.length).to.eql(pm.collectionVariables.get(\"prodCount\"), \"Number of products is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test('Should contain product what was create at the last time', () => {\r",
													"    const lastProduct = allProducts[allProducts.length - 1]\r",
													"    pm.expect(JSON.stringify(lastProduct)).to.eql(JSON.stringify(addedProduct), \"Last product is not added product\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the first products page",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"let prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"prodListSchema.minItems = parseInt(pm.collectionVariables.get('prodPageSize'))\r",
													"prodListSchema.maxItems = parseInt(pm.collectionVariables.get('prodPageSize'))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?page=1&pageSize={{prodPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "page",
													"value": "1"
												},
												{
													"key": "pageSize",
													"value": "{{prodPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the last products page with created product",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const prodCount = pm.collectionVariables.get(\"prodCount\")\r",
													"const prodPageSize = pm.collectionVariables.get(\"prodPageSize\")\r",
													"pm.collectionVariables.set(\"prodPageCount\", Math.ceil(prodCount / prodPageSize))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageProd = pm.response.json()\r",
													"const addedProd = JSON.parse(pm.collectionVariables.get(\"addedProduct\"))\r",
													"let prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"const prodCount = pm.collectionVariables.get(\"prodCount\")\r",
													"const prodPageSize = pm.collectionVariables.get(\"prodPageSize\")\r",
													"const prodPageCount = pm.collectionVariables.get(\"prodPageCount\")\r",
													"const correctListLen = prodCount - (prodPageCount - 1) * prodPageSize\r",
													"\r",
													"prodListSchema.minItems = correctListLen\r",
													"prodListSchema.maxItems = correctListLen\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test('Should contain product what was create at the last time', () => {\r",
													"    const lastProduct = pageProd[pageProd.length - 1]\r",
													"    pm.expect(JSON.stringify(lastProduct)).to.eql(JSON.stringify(addedProd), \"Last product is not showed in the last page\")\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?page={{prodPageCount}}&pageSize={{prodPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "page",
													"value": "{{prodPageCount}}"
												},
												{
													"key": "pageSize",
													"value": "{{prodPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Change the name, the price and the description in the created test",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"id = pm.collectionVariables.get(\"addedProductId\")\r",
													"newName = pm.variables.replaceIn(\"{{$randomProduct}}\")\r",
													"newPrice = parseInt(pm.variables.replaceIn(\"{{$randomInt}}\"))\r",
													"newDesc = pm.variables.replaceIn(\"{{$randomLoremParagraph}}\")\r",
													"\r",
													"const upProd = {\r",
													"    id: id,\r",
													"    name: newName,\r",
													"    price: newPrice,\r",
													"    description: newDesc\r",
													"}\r",
													"\r",
													"pm.variables.set('body', JSON.stringify(upProd));\r",
													"pm.collectionVariables.set(\"upProd\", JSON.stringify(upProd))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"const upProd = JSON.parse(pm.collectionVariables.get(\"upProd\"))\r",
													"const addedProd = JSON.parse(pm.collectionVariables.get(\"addedProduct\"))\r",
													"const respProd = pm.response.json()\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce product should has correct changed and stable data\", () => {\r",
													"    pm.expect(respProd.id).to.eql(addedProd.id, \"Responce product ID is not correct\")\r",
													"    pm.expect(respProd.name).to.eql(upProd.name, \"Responce product name is not correct\")\r",
													"    pm.expect(respProd.price).to.eql(upProd.price, \"Responce product price is not correct\")\r",
													"    pm.expect(respProd.sku).to.eql(addedProd.sku, \"Responce product sku is not correct\")\r",
													"    pm.expect(respProd.description).to.eql(upProd.description, \"Responce product description is not correct\")\r",
													"\r",
													"    pm.collectionVariables.set(\"addedProduct\", JSON.stringify(respProd))\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "PUT",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the last product page with created and updated product",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const prodCount = pm.collectionVariables.get(\"prodCount\")\r",
													"const prodPageSize = pm.collectionVariables.get(\"prodPageSize\")\r",
													"pm.collectionVariables.set(\"prodPageCount\", Math.ceil(prodCount / prodPageSize))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageProd = pm.response.json()\r",
													"const addedProd = JSON.parse(pm.collectionVariables.get(\"addedProduct\"))\r",
													"let prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"const prodCount = pm.collectionVariables.get(\"prodCount\")\r",
													"const prodPageSize = pm.collectionVariables.get(\"prodPageSize\")\r",
													"const prodPageCount = pm.collectionVariables.get(\"prodPageCount\")\r",
													"const correctListLen = prodCount - (prodPageCount - 1) * prodPageSize\r",
													"\r",
													"prodListSchema.minItems = correctListLen\r",
													"prodListSchema.maxItems = correctListLen\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test('Should contain product what was create at the last time', () => {\r",
													"    const lastProduct = pageProd[pageProd.length - 1]\r",
													"    pm.expect(JSON.stringify(lastProduct)).to.eql(JSON.stringify(addedProd), \"Last product is not showed in the last page\")\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?page={{prodPageCount}}&pageSize={{prodPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "page",
													"value": "{{prodPageCount}}"
												},
												{
													"key": "pageSize",
													"value": "{{prodPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Create product with most expencive price and name with first position in the ASCII table",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"sortProductId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"sortProduct\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"name\": \" !!CAKE\",\r\n    \"price\": 9999999999999,\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort products by name with ascendens order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const sortProduct = JSON.parse(pm.collectionVariables.get(\"sortProduct\"))\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of products\", () => {\r",
													"    pm.expect(allProducts.length).to.eql(pm.collectionVariables.get(\"prodCount\"), \"Number of products is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test(\"Should contain the previously created product in the first position\", () => {\r",
													"    const firstProd = JSON.stringify(allProducts[0])\r",
													"    const sortProd = JSON.stringify(sortProduct)\r",
													"    \r",
													"    pm.expect(firstProd).to.eql(sortProd, \"First product in the sorted list is not correct\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?sortOrder=ASC&sortKey=name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "ASC"
												},
												{
													"key": "sortKey",
													"value": "name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort products by price with descendens order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const sortProduct = JSON.parse(pm.collectionVariables.get(\"sortProduct\"))\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of products\", () => {\r",
													"    pm.expect(allProducts.length).to.eql(pm.collectionVariables.get(\"prodCount\"), \"Number of products is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test(\"Should contain the previously created product in the first position\", () => {\r",
													"    const firstProd = JSON.stringify(allProducts[0])\r",
													"    const sortProd = JSON.stringify(sortProduct)\r",
													"\r",
													"    pm.expect(firstProd).to.eql(sortProd, \"First product in the sorted list is not correct\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?sortOrder=DESC&sortKey=price",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "DESC"
												},
												{
													"key": "sortKey",
													"value": "price"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the sorted product",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") - 1)\r",
													"const delProd = JSON.stringify(pm.response.json())\r",
													"const sortProd = pm.collectionVariables.get(\"sortProduct\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted product\", () => {\r",
													"    pm.expect(delProd).to.eql(sortProd)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{sortProductId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{sortProductId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the added product",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") - 1)\r",
													"const delProd = JSON.stringify(pm.response.json())\r",
													"const addedProd = pm.collectionVariables.get(\"addedProduct\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted product\", () => {\r",
													"    pm.expect(delProd).to.eql(addedProd)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{addedProductId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{addedProductId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "List all products after delete product",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const addedProduct = JSON.parse(pm.collectionVariables.get(\"addedProduct\"))\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of products\", () => {\r",
													"    pm.expect(allProducts.length).to.eql(pm.collectionVariables.get(\"prodCount\"), \"Number of products is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test('Should list all product except the deleted product', () => {\r",
													"    deletedProd = JSON.stringify(addedProduct)\r",
													"    for (let i = 0; i < allProducts.length; i++) {\r",
													"        let prod = JSON.stringify(allProducts[i])\r",
													"        pm.expect(prod).not.to.eql(deletedProd, \"List has the product previously deleted\")\r",
													"    }\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "Users flow",
							"item": [
								{
									"name": "List all users",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const userListSchema = {\r",
													"    \"type\": \"array\",\r",
													"    \"items\":{\r",
													"        \"type\": \"object\",\r",
													"        \"properties\": {\r",
													"            \"id\": { \r",
													"                \"type\": \"integer\",\r",
													"                \"minimum\": 1\r",
													"            },\r",
													"            \"firstName\": { \"type\": \"string\" },\r",
													"            \"LastName\": { \"type\": \"string\" },\r",
													"            \"email\": { \"type\": \"string\" },\r",
													"            \"dateOfBirth\": { \"type\": \"string\" },\r",
													"            \"emailVerified\": { \"type\": \"boolean\" },\r",
													"            \"signUpDate\": { \"type\": \"string\" },\r",
													"            \"status\": { \"type\": \"string\" },\r",
													"            \"level\": { \"type\": \"string\" }\r",
													"        },\r",
													"        \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
													"    }\r",
													"}\r",
													"\r",
													"pm.collectionVariables.set(\"userListJsonSchema\", JSON.stringify(userListSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allUsers = pm.response.json()\r",
													"const userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"pm.test(\"Responce has valid user's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"userCount\", allUsers.length)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create new user with random properties",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
													"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
													"\r",
													"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
													"const randomMon = Math.floor(Math.random() * 12)\r",
													"const randomDay = Math.floor(Math.random() * 28)\r",
													"\r",
													"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
													"\r",
													"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
													"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
													"pm.variables.set(\"randUserLevel\", randLevel)\r",
													"\r",
													"const userSchema = {\r",
													"    \"type\": \"object\",\r",
													"    \"properties\": {\r",
													"        \"id\": { \r",
													"            \"type\": \"integer\",\r",
													"            \"minimum\": 1\r",
													"        },\r",
													"        \"firstName\": { \"type\": \"string\" },\r",
													"        \"LastName\": { \"type\": \"string\" },\r",
													"        \"email\": { \"type\": \"string\" },\r",
													"        \"dateOfBirth\": { \"type\": \"string\" },\r",
													"        \"emailVerified\": { \"type\": \"boolean\" },\r",
													"        \"signUpDate\": { \"type\": \"string\" },\r",
													"        \"status\": { \"type\": \"string\" },\r",
													"        \"level\": { \"type\": \"string\" }\r",
													"    },\r",
													"    \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
													"}\r",
													"\r",
													"pm.collectionVariables.set(\"userJsonSchema\", JSON.stringify(userSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating users's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"addedUserId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"addedUser\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\",\r\n    \"level\": \"{{randUserLevel}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "Get information about created user",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"const respUser = JSON.stringify(pm.response.json())\r",
													"const addedUser = pm.collectionVariables.get(\"addedUser\")\r",
													"\r",
													"pm.test(\"Validating users's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should be the created user\", () => {\r",
													"    pm.expect(addedUser).to.eql(respUser, \"Responce user is not added user\")\r",
													"})\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users/{{addedUserId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users",
												"{{addedUserId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the first users page",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"let userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"userListSchema.minItems = parseInt(pm.collectionVariables.get('userPageSize'))\r",
													"userListSchema.maxItems = parseInt(pm.collectionVariables.get('userPageSize'))\r",
													"\r",
													"pm.test(\"Responce has valid user's list JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users?page=1&pageSize={{userPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											],
											"query": [
												{
													"key": "page",
													"value": "1"
												},
												{
													"key": "pageSize",
													"value": "{{userPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the last users page with created user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const userCount = pm.collectionVariables.get(\"userCount\")\r",
													"const userPageSize = pm.collectionVariables.get(\"userPageSize\")\r",
													"pm.collectionVariables.set(\"userPageCount\", Math.ceil(userCount / userPageSize))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageUser = pm.response.json()\r",
													"const addedUser = JSON.parse(pm.collectionVariables.get(\"addedUser\"))\r",
													"let userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"const userCount = pm.collectionVariables.get(\"userCount\")\r",
													"const userPageSize = pm.collectionVariables.get(\"userPageSize\")\r",
													"const userPageCount = pm.collectionVariables.get(\"userPageCount\")\r",
													"const correctListLen = userCount - (userPageCount - 1) * userPageSize\r",
													"\r",
													"userListSchema.minItems = correctListLen\r",
													"userListSchema.maxItems = correctListLen\r",
													"\r",
													"pm.test(\"Responce has valid user's list JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.test('Should contain user data what was create at the last time', () => {\r",
													"    const lastUser = pageUser[pageUser.length - 1]\r",
													"    pm.expect(JSON.stringify(lastUser)).to.eql(JSON.stringify(addedUser), \"Last product is not showed in the last page\")\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users?page={{userPageCount}}&pageSize={{userPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											],
											"query": [
												{
													"key": "page",
													"value": "{{userPageCount}}"
												},
												{
													"key": "pageSize",
													"value": "{{userPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Change all possibly properties of the created user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"id = pm.collectionVariables.get(\"addedUserId\")\r",
													"newFirstName = pm.variables.replaceIn(\"{{$randomFirstName}}\")\r",
													"newLastName = pm.variables.replaceIn(\"{{$randomLastName}}\")\r",
													"newPrice = parseInt(pm.variables.replaceIn(\"{{$randomInt}}\"))\r",
													"newDesc = pm.variables.replaceIn(\"{{$randomLoremParagraph}}\")\r",
													"\r",
													"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
													"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
													"\r",
													"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
													"const randomMon = Math.floor(Math.random() * 12)\r",
													"const randomDay = Math.floor(Math.random() * 28)\r",
													"\r",
													"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
													"\r",
													"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
													"pm.variables.set(\"randUserLevel\", randLevel)\r",
													"\r",
													"const upUser = {\r",
													"    \"firstName\": newFirstName,\r",
													"    \"lastName\": newLastName,\r",
													"    \"email\": `${newFirstName}_${newLastName}@${pm.variables.replaceIn('{{$randomDomainWord}}')}.${pm.variables.replaceIn('{{$randomDomainSuffix}}')}`,\r",
													"    \"dateOfBirth\": `${randomBithdayYear}-${randomMon}-${randomDay}`,\r",
													"    \"emailVerified\": (/true/).test(pm.variables.replaceIn('{{$randomBoolean}}')),\r",
													"    \"level\": randLevel,\r",
													"    \"id\": id\r",
													"}\r",
													"\r",
													"pm.variables.set('body', JSON.stringify(upUser));\r",
													"pm.collectionVariables.set(\"upUser\", JSON.stringify(upUser))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"const upUser = JSON.parse(pm.collectionVariables.get(\"upUser\"))\r",
													"const addedUser = JSON.parse(pm.collectionVariables.get(\"addedUser\"))\r",
													"const respUser = pm.response.json()\r",
													"\r",
													"pm.test(\"Validating users's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce product should has correct changed and stable data\", () => {\r",
													"    pm.expect(respUser.id).to.eql(addedUser.id, \"Responce users ID is not correct\")\r",
													"    pm.expect(respUser.firstName).to.eql(upUser.firstName, \"Responce user's first name is not correct\")\r",
													"    pm.expect(respUser.lastName).to.eql(upUser.lastName, \"Responce user's last name is not correct\")\r",
													"    pm.expect(respUser.email).to.eql(upUser.email, \"Responce user's email is not correct\")\r",
													"    pm.expect(respUser.dateOfBirth).to.eql(upUser.dateOfBirth, \"Responce user's date of birthday is not correct\")\r",
													"    pm.expect(respUser.emailVerified).to.eql(upUser.emailVerified, \"Responce user's data about verification on the email is not correct\")\r",
													"    pm.expect(respUser.signUpDate).to.eql(addedUser.signUpDate, \"Responce user's sign up date is not correct\")\r",
													"    pm.expect(respUser.status).to.eql(addedUser.status, \"Responce user's status is not correct\")\r",
													"    pm.expect(respUser.level).to.eql(upUser.level, \"Responce user's level is not correct\")\r",
													"\r",
													"    pm.collectionVariables.set(\"addedUser\", JSON.stringify(respUser))\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "PUT",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the last user page with created and updated user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const userCount = pm.collectionVariables.get(\"userCount\")\r",
													"const userPageSize = pm.collectionVariables.get(\"userPageSize\")\r",
													"pm.collectionVariables.set(\"userPageCount\", Math.ceil(userCount / userPageSize))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageUser = pm.response.json()\r",
													"const addedUser = JSON.parse(pm.collectionVariables.get(\"addedUser\"))\r",
													"let userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"const userCount = pm.collectionVariables.get(\"userCount\")\r",
													"const userPageSize = pm.collectionVariables.get(\"userPageSize\")\r",
													"const userPageCount = pm.collectionVariables.get(\"userPageCount\")\r",
													"const correctListLen = userCount - (userPageCount - 1) * userPageSize\r",
													"\r",
													"userListSchema.minItems = correctListLen\r",
													"userListSchema.maxItems = correctListLen\r",
													"\r",
													"pm.test('Responce has valid user list JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.test('Should contain user what was update at the last time', () => {\r",
													"    const lastUser = pageUser[pageUser.length - 1]\r",
													"    pm.expect(JSON.stringify(lastUser)).to.eql(JSON.stringify(addedUser), \"Last user is not showed in the last page\")\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users?page={{userPageCount}}&pageSize={{userPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											],
											"query": [
												{
													"key": "page",
													"value": "{{userPageCount}}"
												},
												{
													"key": "pageSize",
													"value": "{{userPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Create user with first name for last position by ASCII table and last name with first position by ASCII table",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating user's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"sortUserId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"sortUser\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"firstName\": \" Alice\",\r\n    \"lastName\": \"~Smith\",\r\n    \"email\": \"alice.smith@gmail.com\",\r\n    \"dateOfBirth\": \"1997-10-31\",\r\n    \"emailVerified\": false,\r\n    \"signUpDate\": \"2019-08-24\",\r\n    \"status\": \"active\",\r\n    \"level\": \"lord\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort users by the first name with ascendens order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allUsers = pm.response.json()\r",
													"const sortUserr = JSON.parse(pm.collectionVariables.get(\"sortUser\"))\r",
													"const userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of users\", () => {\r",
													"    pm.expect(allUsers.length).to.eql(pm.collectionVariables.get(\"userCount\"), \"Number of users is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test(\"Should contain the previously created user in the first position\", () => {\r",
													"    const firstUser = JSON.stringify(allUsers[0])\r",
													"    const sortUser = JSON.stringify(sortUserr)\r",
													"\r",
													"    pm.expect(firstUser).to.eql(sortUser, \"First user in the sorted list is not correct\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users?sortOrder=ASC&sortKey=firstName",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "ASC"
												},
												{
													"key": "sortKey",
													"value": "firstName"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort users by price with descendens order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allUsers = pm.response.json()\r",
													"const sortUserr = JSON.parse(pm.collectionVariables.get(\"sortUser\"))\r",
													"const userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of users\", () => {\r",
													"    pm.expect(allUsers.length).to.eql(pm.collectionVariables.get(\"userCount\"), \"Number of users is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test(\"Should contain the previously created user in the first position\", () => {\r",
													"    const firstUser = JSON.stringify(allUsers[0])\r",
													"    const sortUser = JSON.stringify(sortUserr)\r",
													"    \r",
													"    pm.expect(firstUser).to.eql(sortUser, \"First user in the sorted list is not correct\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users?sortOrder=DESC&sortKey=lastName",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "DESC"
												},
												{
													"key": "sortKey",
													"value": "lastName"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the sorted user",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") - 1)\r",
													"const delUser = JSON.stringify(pm.response.json())\r",
													"const sortUser = pm.collectionVariables.get(\"sortUser\")\r",
													"\r",
													"pm.test(\"Validating user's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted user\", () => {\r",
													"    pm.expect(delUser).to.eql(sortUser)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users/{{sortUserId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users",
												"{{sortUserId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the added user",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") - 1)\r",
													"const delUser = JSON.stringify(pm.response.json())\r",
													"const addedUser = pm.collectionVariables.get(\"addedUser\")\r",
													"\r",
													"pm.test(\"Validating user's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted user\", () => {\r",
													"    pm.expect(delUser).to.eql(addedUser)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users/{{addedUserId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users",
												"{{addedUserId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "List all users after delete users",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allUsers = pm.response.json()\r",
													"const addedUser = JSON.parse(pm.collectionVariables.get(\"addedUser\"))\r",
													"const userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of users\", () => {\r",
													"    pm.expect(allUsers.length).to.eql(pm.collectionVariables.get(\"userCount\"), \"Number of users is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test('Should list all users except the deleted user', () => {\r",
													"    deletedUser = JSON.stringify(addedUser)\r",
													"    for (let i = 0; i < allUsers.length; i++) {\r",
													"        let user = JSON.stringify(allUsers[i])\r",
													"        pm.expect(user).not.to.eql(deletedUser, \"List has the user previously deleted\")\r",
													"    }\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "Orders flow",
							"item": [
								{
									"name": "List all orders",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const orderListSchema = {\r",
													"    \"type\": \"array\",\r",
													"    \"items\":{\r",
													"        \"type\": \"object\",\r",
													"        \"properties\": {\r",
													"            \"id\": { \r",
													"                \"type\": \"integer\",\r",
													"                \"minimum\": 1\r",
													"            },\r",
													"            \"name\": { \"type\": \"string\" },\r",
													"            \"sku\": { \"type\": \"integer\" }\r",
													"        },\r",
													"        \"require\": [\"id\", \"name\", \"sku\"]\r",
													"    }\r",
													"}\r",
													"pm.collectionVariables.set(\"orderListJsonSchema\", JSON.stringify(orderListSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allOrders = pm.response.json()\r",
													"const orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"console.log(orderListSchema)\r",
													"pm.test(\"Responce has valid order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"orderCount\", allOrders.length)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create new order with random properties",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const body = {\r",
													"    \"name\": `order${pm.collectionVariables.get('orderCount')}`,\r",
													"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}'))\r",
													"}\r",
													"\r",
													"const orderSchema = {\r",
													"    \"type\": \"object\",\r",
													"    \"properties\": {\r",
													"        \"id\": { \r",
													"            \"type\": \"integer\",\r",
													"            \"minimum\": 1\r",
													"        },\r",
													"        \"name\": { \"type\": \"string\" },\r",
													"        \"sku\": { \"type\": \"integer\" }\r",
													"    },\r",
													"    \"require\": [\"id\", \"name\", \"sku\"]\r",
													"}\r",
													"\r",
													"pm.variables.set(\"body\", JSON.stringify(body))\r",
													"pm.collectionVariables.set(\"orderJsonSchema\", JSON.stringify(orderSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"addedOrderId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"addedOrder\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Get information about created order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"const respOrder = JSON.stringify(pm.response.json())\r",
													"const addedOrder = pm.collectionVariables.get(\"addedOrder\")\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should be the created order\", () => {\r",
													"    pm.expect(addedOrder).to.eql(respOrder, \"Responce order is not added order\")\r",
													"})\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders/{{addedOrderId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders",
												"{{addedOrderId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the first orders page",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"let orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"\r",
													"orderListSchema.minItems = parseInt(pm.collectionVariables.get('orderPageSize'))\r",
													"orderListSchema.maxItems = parseInt(pm.collectionVariables.get('orderPageSize'))\r",
													"\r",
													"pm.test(\"Responce has valid order's list JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users?page=1&pageSize={{orderPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											],
											"query": [
												{
													"key": "page",
													"value": "1"
												},
												{
													"key": "pageSize",
													"value": "{{orderPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the last orders page with created order",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const orderCount = pm.collectionVariables.get(\"orderCount\")\r",
													"const orderPageSize = pm.collectionVariables.get(\"orderPageSize\")\r",
													"pm.collectionVariables.set(\"orderPageCount\", Math.ceil(orderCount / orderPageSize))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageOrder = pm.response.json()\r",
													"const addedOrder = JSON.parse(pm.collectionVariables.get(\"addedOrder\"))\r",
													"let orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"\r",
													"const orderCount = pm.collectionVariables.get(\"orderCount\")\r",
													"const orderPageSize = pm.collectionVariables.get(\"orderPageSize\")\r",
													"const orderPageCount = pm.collectionVariables.get(\"orderPageCount\")\r",
													"const correctListLen = orderCount - (orderPageCount - 1) * orderPageSize\r",
													"\r",
													"orderListSchema.minItems = correctListLen\r",
													"orderListSchema.maxItems = correctListLen\r",
													"\r",
													"pm.test(\"Responce has valid order's list JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.test('Should contain order data what was create at the last time', () => {\r",
													"    const lastOrder = pageOrder[pageOrder.length - 1]\r",
													"    pm.expect(JSON.stringify(lastOrder)).to.eql(JSON.stringify(addedOrder), \"Last order is not showed in the last page\")\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders?page={{orderPageCount}}&pageSize={{orderPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											],
											"query": [
												{
													"key": "page",
													"value": "{{orderPageCount}}"
												},
												{
													"key": "pageSize",
													"value": "{{orderPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Change all possibly properties of the created user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"id = pm.collectionVariables.get(\"addedOrderId\")\r",
													"\r",
													"const upOrder = {\r",
													"    \"id\": id,\r",
													"    \"name\": 'orderChanged',\r",
													"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}'))\r",
													"}\r",
													"\r",
													"pm.variables.set('body', JSON.stringify(upOrder));\r",
													"pm.collectionVariables.set(\"upOrder\", JSON.stringify(upOrder))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"const upOrder = JSON.parse(pm.collectionVariables.get(\"upOrder\"))\r",
													"const addedOrder = JSON.parse(pm.collectionVariables.get(\"addedOrder\"))\r",
													"const respOrder = pm.response.json()\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce order should has correct changed and stable data\", () => {\r",
													"    pm.expect(respOrder.id).to.eql(addedOrder.id)\r",
													"    pm.expect(respOrder.name).to.eql(upOrder.name)\r",
													"    pm.expect(respOrder.sku).to.eql(upOrder.sku)\r",
													"\r",
													"    pm.collectionVariables.set(\"addedOrder\", JSON.stringify(respOrder))\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "PUT",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open the last user page with created and updated user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const orderCount = pm.collectionVariables.get(\"orderCount\")\r",
													"const orderPageSize = pm.collectionVariables.get(\"orderPageSize\")\r",
													"pm.collectionVariables.set(\"orderPageCount\", Math.ceil(orderCount / orderPageSize))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageOrder = pm.response.json()\r",
													"const addedOrder = JSON.parse(pm.collectionVariables.get(\"addedOrder\"))\r",
													"let orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"\r",
													"const orderCount = pm.collectionVariables.get(\"orderCount\")\r",
													"const orderPageSize = pm.collectionVariables.get(\"orderPageSize\")\r",
													"const orderPageCount = pm.collectionVariables.get(\"orderPageCount\")\r",
													"const correctListLen = orderCount - (orderPageCount - 1) * orderPageSize\r",
													"\r",
													"orderListSchema.minItems = correctListLen\r",
													"orderListSchema.maxItems = correctListLen\r",
													"\r",
													"pm.test(\"Responce has valid order's list JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.test('Should contain order what was update at the last time', () => {\r",
													"    const lastOrder = pageOrder[pageOrder.length - 1]\r",
													"    pm.expect(JSON.stringify(lastOrder)).to.eql(JSON.stringify(addedOrder), \"Last order is not showed in the last page\")\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders?page={{orderPageCount}}&pageSize={{orderPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											],
											"query": [
												{
													"key": "page",
													"value": "{{orderPageCount}}"
												},
												{
													"key": "pageSize",
													"value": "{{orderPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Create order with name for first position by ASCII table and sku or last position by int",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"sortOrderId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"sortOrder\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"name\": \" order\",\r\n    \"sku\": 9999999999999999\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort orders by the name with ascendens order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allOrders = pm.response.json()\r",
													"const sortOrderr = JSON.parse(pm.collectionVariables.get(\"sortOrder\"))\r",
													"const orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of orders\", () => {\r",
													"    pm.expect(allOrders.length).to.eql(pm.collectionVariables.get(\"orderCount\"), \"Number of orders is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test(\"Should contain the previously created user in the first position\", () => {\r",
													"    const firstOrder = JSON.stringify(allOrders[0])\r",
													"    const sortOrder = JSON.stringify(sortOrderr)\r",
													"\r",
													"    pm.expect(firstOrder).to.eql(sortOrder, \"First user in the sorted list is not correct\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders?sortOrder=ASC&sortKey=name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "ASC"
												},
												{
													"key": "sortKey",
													"value": "name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort orders by sku with descendens order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allOrders = pm.response.json()\r",
													"const sortOrderr = JSON.parse(pm.collectionVariables.get(\"sortOrder\"))\r",
													"const orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of orders\", () => {\r",
													"    pm.expect(allOrders.length).to.eql(pm.collectionVariables.get(\"orderCount\"), \"Number of orders is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test(\"Should contain the previously created order in the first position\", () => {\r",
													"    const firstOrder = JSON.stringify(allOrders[0])\r",
													"    const sortOrder = JSON.stringify(sortOrderr)\r",
													"    \r",
													"    pm.expect(firstOrder).to.eql(sortOrder, \"First user in the sorted list is not correct\")\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders?sortOrder=DESC&sortKey=sku",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "DESC"
												},
												{
													"key": "sortKey",
													"value": "sku"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the sorted order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") - 1)\r",
													"const delOrder = JSON.stringify(pm.response.json())\r",
													"const sortOrder = pm.collectionVariables.get(\"sortOrder\")\r",
													"\r",
													"pm.test(\"Validating user's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted order\", () => {\r",
													"    pm.expect(delOrder).to.eql(sortOrder)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders/{{sortOrderId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders",
												"{{sortOrderId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the added order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") - 1)\r",
													"const delOrder = JSON.stringify(pm.response.json())\r",
													"const addedOrder = pm.collectionVariables.get(\"addedOrder\")\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted order\", () => {\r",
													"    pm.expect(delOrder).to.eql(addedOrder)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders/{{addedOrderId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders",
												"{{addedOrderId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "List all products after delete product Copy",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allOrders = pm.response.json()\r",
													"const addedOrder = JSON.parse(pm.collectionVariables.get(\"addedOrder\"))\r",
													"const orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of orders\", () => {\r",
													"    pm.expect(allOrders.length).to.eql(pm.collectionVariables.get(\"orderCount\"), \"Number of orders is incorrect\")\r",
													"})\r",
													"\r",
													"pm.test('Should list all users except the deleted user', () => {\r",
													"    deletedOrder = JSON.stringify(addedOrder)\r",
													"    for (let i = 0; i < allOrders.length; i++) {\r",
													"        let order = JSON.stringify(allOrders[i])\r",
													"        pm.expect(order).not.to.eql(deletedOrder, \"List has the user previously deleted\")\r",
													"    }\r",
													"})\r",
													"\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "User story flow",
							"item": [
								{
									"name": "List all users before user flow",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const userListSchema = {\r",
													"    \"type\": \"array\",\r",
													"    \"items\":{\r",
													"        \"type\": \"object\",\r",
													"        \"properties\": {\r",
													"            \"id\": { \r",
													"                \"type\": \"integer\",\r",
													"                \"minimum\": 1\r",
													"            },\r",
													"            \"firstName\": { \"type\": \"string\" },\r",
													"            \"LastName\": { \"type\": \"string\" },\r",
													"            \"email\": { \"type\": \"string\" },\r",
													"            \"dateOfBirth\": { \"type\": \"string\" },\r",
													"            \"emailVerified\": { \"type\": \"boolean\" },\r",
													"            \"signUpDate\": { \"type\": \"string\" },\r",
													"            \"status\": { \"type\": \"string\" },\r",
													"            \"level\": { \"type\": \"string\" }\r",
													"        },\r",
													"        \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
													"    }\r",
													"}\r",
													"\r",
													"pm.collectionVariables.set(\"userListJsonSchema\", JSON.stringify(userListSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allUsers = pm.response.json()\r",
													"const userListSchema = JSON.parse(pm.collectionVariables.get(\"userListJsonSchema\"))\r",
													"\r",
													"pm.test(\"Responce has valid user's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userListSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"userCount\", allUsers.length)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "List all products before user flow",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"url = `${pm.collectionVariables.get(\"baseUrl\")}/products`\r",
													"newProdCount = pm.collectionVariables.get('addRandomProducts')\r",
													"\r",
													"let i = 0\r",
													"while (i < newProdCount) {\r",
													"        \r",
													"    const newRandProd = {\r",
													"        url: url,\r",
													"        method: 'POST',\r",
													"        header: {\r",
													"            'Content-Type': 'application/json'\r",
													"        },\r",
													"        body: {\r",
													"            mode: 'raw',\r",
													"            raw: JSON.stringify({\r",
													"                \"name\": pm.variables.replaceIn(\"{{$randomProduct}}\"),\r",
													"                \"price\": parseFloat(pm.variables.replaceIn(\"{{$randomPrice}}\")),\r",
													"                \"sku\": parseInt(pm.variables.replaceIn(\"{{$randomInt}}\")),\r",
													"                \"description\": pm.variables.replaceIn(\"{{$randomLoremParagraph}}\")\r",
													"            })\r",
													"        }\r",
													"    }\r",
													"\r",
													"    pm.sendRequest(newRandProd, (error, response) => {\r",
													"        console.log(error ? error : response.json())\r",
													"\r",
													"        pm.test(\"Random product was added\", () => {\r",
													"            pm.expect(error).to.eql(null)\r",
													"            pm.expect(response).to.have.property('code', 201)\r",
													"            pm.expect(response).to.have.property('status', 'Created')\r",
													"        })\r",
													"    })\r",
													"    i = i + 1\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"prodCount\", allProducts.length)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											]
										}
									},
									"response": []
								},
								{
									"name": "List all orders before user flow",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const orderListSchema = {\r",
													"    \"type\": \"array\",\r",
													"    \"items\":{\r",
													"        \"type\": \"object\",\r",
													"        \"properties\": {\r",
													"            \"id\": { \r",
													"                \"type\": \"integer\",\r",
													"                \"minimum\": 1\r",
													"            },\r",
													"            \"name\": { \"type\": \"string\" },\r",
													"            \"sku\": { \"type\": \"integer\" }\r",
													"        },\r",
													"        \"require\": [\"id\", \"name\", \"sku\"]\r",
													"    }\r",
													"}\r",
													"pm.collectionVariables.set(\"orderListJsonSchema\", JSON.stringify(orderListSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allOrders = pm.response.json()\r",
													"const orderListSchema = JSON.parse(pm.collectionVariables.get(\"orderListJsonSchema\"))\r",
													"console.log(orderListSchema)\r",
													"pm.test(\"Responce has valid order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderListSchema)\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"orderCount\", allOrders.length)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Sign up the new user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const curDate = pm.variables.replaceIn(\"{{$isoTimestamp}}\").split(\"T\")[0]\r",
													"\r",
													"const newUser = {\r",
													"    \"firstName\": \"Guts\",\r",
													"    \"lastName\": \"Gambinovuch\",\r",
													"    \"email\": \"real_guts@hotmail.com\",\r",
													"    \"dateOfBirth\": \"1234-11-11\",\r",
													"    \"emailVerified\": false,\r",
													"    \"signUpDate\": curDate,\r",
													"    \"status\": \"active\",\r",
													"    \"level\": \"cunsomer\"\r",
													"}\r",
													"\r",
													"const userSchema = {\r",
													"    \"type\": \"object\",\r",
													"    \"properties\": {\r",
													"        \"id\": { \r",
													"            \"type\": \"integer\",\r",
													"            \"minimum\": 1\r",
													"        },\r",
													"        \"firstName\": { \"type\": \"string\" },\r",
													"        \"LastName\": { \"type\": \"string\" },\r",
													"        \"email\": { \"type\": \"string\" },\r",
													"        \"dateOfBirth\": { \"type\": \"string\" },\r",
													"        \"emailVerified\": { \"type\": \"boolean\" },\r",
													"        \"signUpDate\": { \"type\": \"string\" },\r",
													"        \"status\": { \"type\": \"string\" },\r",
													"        \"level\": { \"type\": \"string\" }\r",
													"    },\r",
													"    \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
													"}\r",
													"\r",
													"pm.variables.set(\"body\", JSON.stringify(newUser))\r",
													"pm.collectionVariables.set(\"userJsonSchema\", JSON.stringify(userSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"const requestUser = JSON.parse(pm.variables.get(\"body\"))\r",
													"const responceUser = pm.response.json()\r",
													"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") + 1)\r",
													"\r",
													"pm.test(\"Validating users's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Resonce user should be equa lto the created\", () => {\r",
													"    const reqKeys = Object.keys(requestUser)\r",
													"\r",
													"    for (let key of reqKeys) {\r",
													"        pm.expect(requestUser[key]).to.eql(responceUser[key])\r",
													"    }\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"addedUserId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"addedUser\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "Added user verifyed account",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
													"const addedUser = JSON.parse(pm.collectionVariables.get(\"addedUser\"))\r",
													"const respUser = pm.response.json()\r",
													"\r",
													"pm.test(\"Validating users's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(userSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce product should has correct changed and stable data\", () => {\r",
													"    pm.expect(respUser.id).to.eql(addedUser.id, \"Responce users ID is not correct\")\r",
													"    pm.expect(respUser.firstName).to.eql(addedUser.firstName, \"Responce user's first name is not correct\")\r",
													"    pm.expect(respUser.lastName).to.eql(addedUser.lastName, \"Responce user's last name is not correct\")\r",
													"    pm.expect(respUser.email).to.eql(addedUser.email, \"Responce user's email is not correct\")\r",
													"    pm.expect(respUser.dateOfBirth).to.eql(addedUser.dateOfBirth, \"Responce user's date of birthday is not correct\")\r",
													"    pm.expect(respUser.emailVerified).to.eql(true, \"Responce user's data about verification on the email should be true\")\r",
													"    pm.expect(respUser.signUpDate).to.eql(addedUser.signUpDate, \"Responce user's sign up date is not correct\")\r",
													"    pm.expect(respUser.status).to.eql(addedUser.status, \"Responce user's status is not correct\")\r",
													"    pm.expect(respUser.level).to.eql(addedUser.level, \"Responce user's level is not correct\")\r",
													"\r",
													"    pm.collectionVariables.set(\"addedUser\", JSON.stringify(respUser))\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "PUT",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"id\": {{addedUserId}},\r\n    \"emailVerified\": true\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/users",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"users"
											]
										}
									},
									"response": []
								},
								{
									"name": "Open random product page by the added user",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const prodCount = pm.collectionVariables.get(\"prodCount\")\r",
													"const prodPageSize = pm.collectionVariables.get(\"prodPageSize\")\r",
													"const prodPageCount = Math.ceil(prodCount / prodPageSize)\r",
													"\r",
													"let randomPage = null\r",
													"\r",
													"if (prodPageCount === 1) {\r",
													"    randomPage = 1\r",
													"}\r",
													"else {\r",
													"    randomPage = Math.floor(Math.random() * prodPageCount)\r",
													"}\r",
													"\r",
													"pm.collectionVariables.set(\"prodPageCount\", Math.ceil(prodCount / prodPageSize))\r",
													"pm.variables.set(\"randomPage\", randomPage)"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const pageProd = pm.response.json()\r",
													"let prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"const prodCount = pm.collectionVariables.get(\"prodCount\")\r",
													"const prodPageSize = pm.collectionVariables.get(\"prodPageSize\")\r",
													"const prodPageCount = pm.collectionVariables.get(\"prodPageCount\")\r",
													"const correctListLen = prodCount - (prodPageCount - 1) * prodPageSize\r",
													"\r",
													"prodListSchema.minItems = 0\r",
													"prodListSchema.maxItems = parseInt(prodPageSize)\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"const randomProduct = pageProd[Math.floor(Math.random() * pageProd.length)]\r",
													"const randomProdId = randomProduct.id\r",
													"pm.collectionVariables.set(\"randomProduct\", JSON.stringify(randomProduct))\r",
													"pm.collectionVariables.set(\"randomProdId\", randomProdId)"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?page={{randomPage}}&pageSize={{prodPageSize}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "page",
													"value": "{{randomPage}}"
												},
												{
													"key": "pageSize",
													"value": "{{prodPageSize}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Open random product from the previosly opened page",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"const respProd = pm.response.json()\r",
													"const randProd = pm.collectionVariables.get(\"randomProduct\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should be the previosly choosed product\", () => {\r",
													"    pm.expect(randProd).to.eql(JSON.stringify(respProd), \"Responce product is not previously selected product\")\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"randProdSku\", respProd.sku)"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{randomProdId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{randomProdId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create new order with random choosed product",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const body = {\r",
													"    \"name\": `order${pm.collectionVariables.get('orderCount')}`,\r",
													"    \"sku\": parseInt(pm.collectionVariables.get(\"randProdSku\"))\r",
													"}\r",
													"\r",
													"const orderSchema = {\r",
													"    \"type\": \"object\",\r",
													"    \"properties\": {\r",
													"        \"id\": { \r",
													"            \"type\": \"integer\",\r",
													"            \"minimum\": 1\r",
													"        },\r",
													"        \"name\": { \"type\": \"string\" },\r",
													"        \"sku\": { \"type\": \"integer\" }\r",
													"    },\r",
													"    \"require\": [\"id\", \"name\", \"sku\"]\r",
													"}\r",
													"\r",
													"pm.variables.set(\"body\", JSON.stringify(body))\r",
													"pm.collectionVariables.set(\"orderJsonSchema\", JSON.stringify(orderSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
													"\r",
													"const respOrdSku = pm.response.json().sku\r",
													"const randProdSku = pm.collectionVariables.get(\"randProdSku\")\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Order should be with sku from the random choosed product\", () => {\r",
													"    pm.expect(randProdSku).to.eql(respOrdSku, \"The responce order's SKU is not equal to the random choosed product\")\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"randOrderId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"randOrder\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Sort products by price with ascendence order",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const allProducts = pm.response.json()\r",
													"const prodListSchema = JSON.parse(pm.collectionVariables.get(\"prodListJsonSchema\"))\r",
													"\r",
													"pm.test('Responce has valid JSON schema', () => {\r",
													"    pm.response.to.have.jsonSchema(prodListSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should have actual number of products\", () => {\r",
													"    pm.expect(allProducts.length).to.eql(pm.collectionVariables.get(\"prodCount\"), \"Number of products is incorrect\")\r",
													"})\r",
													"\r",
													"const minPriceProd = allProducts[0]\r",
													"pm.collectionVariables.set(\"minPriceProdId\", minPriceProd.id)\r",
													"pm.collectionVariables.set(\"minPriceProd\", JSON.stringify(minPriceProd))"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products?sortOrder=ASC&sortKey=price",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products"
											],
											"query": [
												{
													"key": "sortOrder",
													"value": "ASC"
												},
												{
													"key": "sortKey",
													"value": "price"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Open product with lowest price from the previosly opened page",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"const respProd = pm.response.json()\r",
													"const minProd = pm.collectionVariables.get(\"minPriceProd\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Should be the previosly choosed product\", () => {\r",
													"    pm.expect(minProd).to.eql(JSON.stringify(respProd), \"Responce product is not previously selected product\")\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"minProdSku\", respProd.sku)"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{minPriceProdId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{minPriceProdId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create new order with product has lowest price",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const body = {\r",
													"    \"name\": `order${pm.collectionVariables.get('orderCount')}`,\r",
													"    \"sku\": parseInt(pm.collectionVariables.get(\"minProdSku\"))\r",
													"}\r",
													"\r",
													"const orderSchema = {\r",
													"    \"type\": \"object\",\r",
													"    \"properties\": {\r",
													"        \"id\": { \r",
													"            \"type\": \"integer\",\r",
													"            \"minimum\": 1\r",
													"        },\r",
													"        \"name\": { \"type\": \"string\" },\r",
													"        \"sku\": { \"type\": \"integer\" }\r",
													"    },\r",
													"    \"require\": [\"id\", \"name\", \"sku\"]\r",
													"}\r",
													"\r",
													"pm.variables.set(\"body\", JSON.stringify(body))\r",
													"pm.collectionVariables.set(\"orderJsonSchema\", JSON.stringify(orderSchema))"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
													"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
													"\r",
													"const respOrdSku = pm.response.json().sku\r",
													"const minProdSku = pm.collectionVariables.get(\"minProdSku\")\r",
													"\r",
													"pm.test(\"Validating order's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(orderSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Order should be with sku from the previously choosed product\", () => {\r",
													"    pm.expect(minProdSku).to.eql(respOrdSku, \"The responce order's SKU is not equal to the previously choosed product\")\r",
													"})\r",
													"\r",
													"pm.collectionVariables.set(\"minOrderId\", pm.response.json().id)\r",
													"pm.collectionVariables.set(\"minOrder\", pm.response.text())"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{body}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/orders",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"orders"
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the random choosed product",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") - 1)\r",
													"const delProd = JSON.stringify(pm.response.json())\r",
													"const randProd = pm.collectionVariables.get(\"randomProduct\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted product\", () => {\r",
													"    pm.expect(delProd).to.eql(randProd)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{randomProdId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{randomProdId}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Remove the choosed product with lowest price",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
													"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") - 1)\r",
													"\r",
													"const delProd = JSON.stringify(pm.response.json())\r",
													"const minProd = pm.collectionVariables.get(\"minPriceProd\")\r",
													"\r",
													"pm.test(\"Validating product's JSON schema\", () => {\r",
													"    pm.response.to.have.jsonSchema(prodSchema)\r",
													"})\r",
													"\r",
													"pm.test(\"Responce should to contain deleted product\", () => {\r",
													"    pm.expect(delProd).to.eql(minProd)\r",
													"})"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/products/{{minPriceProdId}}",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"products",
												"{{minPriceProdId}}"
											]
										}
									},
									"response": []
								}
							]
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test('Responce status is correct', () => {",
									"    if (pm.request.method === \"POST\") {",
									"        pm.response.to.have.status(201)",
									"    }",
									"    else {",
									"        pm.response.to.have.status(200)",
									"    }",
									"});",
									"",
									"pm.test(\"Content-Type is present\", () => {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"pm.test('Content-Type is application/json', () => {",
									"    const contentType = pm.response.headers.get('Content-Type')",
									"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');",
									"});",
									"",
									"pm.test(\"Response time is less than 200ms\", () => {",
									"  pm.expect(pm.response.responseTime).to.be.below(200);",
									"});"
								]
							}
						}
					]
				},
				{
					"name": "Negative cases",
					"item": [
						{
							"name": "Get product with non-existent ID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body should be empty', () => {\r",
											"    respBody = pm.response.json()\r",
											"    pm.expect(Object.keys(respBody)).to.eql([], \"Response has any properties in the body\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products/0",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products",
										"0"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get user with non-existent ID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body should be empty', () => {\r",
											"    respBody = pm.response.json()\r",
											"    pm.expect(Object.keys(respBody)).to.eql([], \"Response has any properties in the body\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users/0",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users",
										"0"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get order with non-existent ID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body should contain \"Cannot GET /orders/0\"', () => {\r",
											"    respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.contain('Cannot GET /odrers/0', \"Response has not message about non-existent order\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/odrers/0",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"odrers",
										"0"
									]
								}
							},
							"response": []
						},
						{
							"name": "Open the non-existant products page",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(200)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body should be empty', () => {\r",
											"    respBody = pm.response.json()\r",
											"    pm.expect(respBody).to.eql([], \"Response has any properties in the body\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products?page=0&pageSize={{prodPageSize}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									],
									"query": [
										{
											"key": "page",
											"value": "0"
										},
										{
											"key": "pageSize",
											"value": "{{prodPageSize}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Open the users page with zero size",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(200)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body should be empty', () => {\r",
											"    respBody = pm.response.json()\r",
											"    pm.expect(respBody).to.eql([], \"Response has any properties in the body\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users?page=1&pageSize=0",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "pageSize",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new product without description",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new product with invalid attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new product with redundant attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\",\r\n    \"additionalAttribute\": {{$randomInt}}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new user without level attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new user with invalid attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\",\r\n    \"lev\": \"cunsomer\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new user with redundant attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\",\r\n    \"level\": \"cunsomer\",\r\n    \"activeness\": true\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new order without SKU attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"nam\": \"{{$randomLoremWord}}\",\r\n    \"sku\": \"{{$randomInt}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new order with invalid attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"nam\": \"{{$randomLoremWord}}\",\r\n    \"sku\": \"{{$randomInt}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new order with redundant attribute",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 400\", () => {\r",
											"    pm.response.to.have.status(400)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response body has any text\")\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"nam\": \"{{$randomLoremWord}}\",\r\n    \"sku\": \"{{$randomInt}}\",\r\n    \"user_id\": 111\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create product with random properties for the negative cases",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
											"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating product's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(prodSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedProductId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedProduct\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Change product atribbutes by invalid ID",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body has \"Item not found with ID\" error message', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).contain('Item not found with ID', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"id\": \"{{addedProductId}}\",\r\n    \"name\": \"{{$randomWord}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create product with random properties for the negative cases Copy",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
											"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating product's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(prodSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedProductId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedProduct\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Add redudant attribute to the product",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body has \"Unexpected attribute\"', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).contain('Unexpected attribute', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"id\": {{addedProductId}},\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\",\r\n    \"optAttribute\": \"{{$randomWord}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create user with random properties for the negative cases",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											"\r",
											"const userSchema = {\r",
											"    \"type\": \"object\",\r",
											"    \"properties\": {\r",
											"        \"id\": { \r",
											"            \"type\": \"integer\",\r",
											"            \"minimum\": 1\r",
											"        },\r",
											"        \"firstName\": { \"type\": \"string\" },\r",
											"        \"LastName\": { \"type\": \"string\" },\r",
											"        \"email\": { \"type\": \"string\" },\r",
											"        \"dateOfBirth\": { \"type\": \"string\" },\r",
											"        \"emailVerified\": { \"type\": \"boolean\" },\r",
											"        \"signUpDate\": { \"type\": \"string\" },\r",
											"        \"status\": { \"type\": \"string\" },\r",
											"        \"level\": { \"type\": \"string\" }\r",
											"    },\r",
											"    \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
											"}\r",
											"\r",
											"pm.collectionVariables.set(\"userJsonSchema\", JSON.stringify(userSchema))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
											"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating users's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(userSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedUserId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedUser\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\",\r\n    \"level\": \"{{randUserLevel}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Change user atribbutes by invalid ID",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"id = pm.collectionVariables.get(\"addedUserId\")\r",
											"newFirstName = pm.variables.replaceIn(\"{{$randomFirstName}}\")\r",
											"newLastName = pm.variables.replaceIn(\"{{$randomLastName}}\")\r",
											"newPrice = parseInt(pm.variables.replaceIn(\"{{$randomInt}}\"))\r",
											"newDesc = pm.variables.replaceIn(\"{{$randomLoremParagraph}}\")\r",
											"\r",
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											"\r",
											"const upUser = {\r",
											"    \"firstName\": newFirstName,\r",
											"    \"lastName\": newLastName,\r",
											"    \"email\": `${newFirstName}_${newLastName}@${pm.variables.replaceIn('{{$randomDomainWord}}')}.${pm.variables.replaceIn('{{$randomDomainSuffix}}')}`,\r",
											"    \"dateOfBirth\": `${randomBithdayYear}-${randomMon}-${randomDay}`,\r",
											"    \"emailVerified\": (/true/).test(pm.variables.replaceIn('{{$randomBoolean}}')),\r",
											"    \"level\": randLevel,\r",
											"    \"id\": `${id}!`\r",
											"}\r",
											"\r",
											"pm.variables.set('body', JSON.stringify(upUser));"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body has \"Item not found with ID\" error message', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).contain('Item not found with ID', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{body}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create user with random properties for the negative cases Copy",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											"\r",
											"const userSchema = {\r",
											"    \"type\": \"object\",\r",
											"    \"properties\": {\r",
											"        \"id\": { \r",
											"            \"type\": \"integer\",\r",
											"            \"minimum\": 1\r",
											"        },\r",
											"        \"firstName\": { \"type\": \"string\" },\r",
											"        \"LastName\": { \"type\": \"string\" },\r",
											"        \"email\": { \"type\": \"string\" },\r",
											"        \"dateOfBirth\": { \"type\": \"string\" },\r",
											"        \"emailVerified\": { \"type\": \"boolean\" },\r",
											"        \"signUpDate\": { \"type\": \"string\" },\r",
											"        \"status\": { \"type\": \"string\" },\r",
											"        \"level\": { \"type\": \"string\" }\r",
											"    },\r",
											"    \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
											"}\r",
											"\r",
											"pm.collectionVariables.set(\"userJsonSchema\", JSON.stringify(userSchema))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
											"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating users's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(userSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedUserId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedUser\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\",\r\n    \"level\": \"{{randUserLevel}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Add redudant attribute to the user",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"id = pm.collectionVariables.get(\"addedUserId\")\r",
											"newFirstName = pm.variables.replaceIn(\"{{$randomFirstName}}\")\r",
											"newLastName = pm.variables.replaceIn(\"{{$randomLastName}}\")\r",
											"newPrice = parseInt(pm.variables.replaceIn(\"{{$randomInt}}\"))\r",
											"newDesc = pm.variables.replaceIn(\"{{$randomLoremParagraph}}\")\r",
											"\r",
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											"\r",
											"const upUser = {\r",
											"    \"firstName\": newFirstName,\r",
											"    \"lastName\": newLastName,\r",
											"    \"email\": `${newFirstName}_${newLastName}@${pm.variables.replaceIn('{{$randomDomainWord}}')}.${pm.variables.replaceIn('{{$randomDomainSuffix}}')}`,\r",
											"    \"dateOfBirth\": `${randomBithdayYear}-${randomMon}-${randomDay}`,\r",
											"    \"emailVerified\": (/true/).test(pm.variables.replaceIn('{{$randomBoolean}}')),\r",
											"    \"level\": randLevel,\r",
											"    \"id\": id,\r",
											"    \"optAttribute\": pm.variables.replaceIn(\"{{$randomWord}}\")\r",
											"}\r",
											"\r",
											"pm.variables.set('body', JSON.stringify(upUser));"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body has \"Unexpected attribute\"', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).contain('Unexpected attribute', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"id\": {{addedProductId}},\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\",\r\n    \"optAttribute\": \"{{$randomWord}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create order with random properties for the negative cases",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const body = {\r",
											"    \"name\": 'order',\r",
											"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}'))\r",
											"}\r",
											"\r",
											"const orderSchema = {\r",
											"    \"type\": \"object\",\r",
											"    \"properties\": {\r",
											"        \"id\": { \r",
											"            \"type\": \"integer\",\r",
											"            \"minimum\": 1\r",
											"        },\r",
											"        \"name\": { \"type\": \"string\" },\r",
											"        \"sku\": { \"type\": \"integer\" }\r",
											"    },\r",
											"    \"require\": [\"id\", \"name\", \"sku\"]\r",
											"}\r",
											"\r",
											"pm.variables.set(\"body\", JSON.stringify(body))\r",
											"pm.collectionVariables.set(\"orderJsonSchema\", JSON.stringify(orderSchema))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
											"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating order's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(orderSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedOrderId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedOrder\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{body}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Change all possibly properties of the created order",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"id = pm.collectionVariables.get(\"addedOrderId\")\r",
											"\r",
											"const upOrder = {\r",
											"    \"id\": `${id}`,\r",
											"    \"name\": 'orderChanged',\r",
											"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}'))\r",
											"}\r",
											"\r",
											"pm.variables.set('body', JSON.stringify(upOrder));\r",
											"pm.collectionVariables.set(\"upOrder\", JSON.stringify(upOrder))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body has \"Item not found with ID\" error message', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).contain('Item not found with ID', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{body}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create order with random properties for the negative cases Copy",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const body = {\r",
											"    \"name\": 'order',\r",
											"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}'))\r",
											"}\r",
											"\r",
											"const orderSchema = {\r",
											"    \"type\": \"object\",\r",
											"    \"properties\": {\r",
											"        \"id\": { \r",
											"            \"type\": \"integer\",\r",
											"            \"minimum\": 1\r",
											"        },\r",
											"        \"name\": { \"type\": \"string\" },\r",
											"        \"sku\": { \"type\": \"integer\" }\r",
											"    },\r",
											"    \"require\": [\"id\", \"name\", \"sku\"]\r",
											"}\r",
											"\r",
											"pm.variables.set(\"body\", JSON.stringify(body))\r",
											"pm.collectionVariables.set(\"orderJsonSchema\", JSON.stringify(orderSchema))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
											"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating order's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(orderSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedOrderId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedOrder\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{body}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Add redudant attribute to order",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"id = pm.collectionVariables.get(\"addedOrderId\")\r",
											"\r",
											"const upOrder = {\r",
											"    \"id\": id,\r",
											"    \"name\": 'orderChanged',\r",
											"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}')),\r",
											"    \"optAttribute\": pm.collectionVariables.replaceIn('{{$randomWord}}')\r",
											"}\r",
											"\r",
											"pm.variables.set('body', JSON.stringify(upOrder));\r",
											"pm.collectionVariables.set(\"upOrder\", JSON.stringify(upOrder))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 404\", () => {\r",
											"    pm.response.to.have.status(404)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a text/html', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('text/html', 'Content type is not \"text/html\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body has \"Unexpected attribute\" error message', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).contain('Unexpected attribute', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{body}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create product with random properties for the negative delete cases",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
											"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating product's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(prodSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedProductId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedProduct\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{$randomProduct}}\",\r\n    \"price\": {{$randomPrice}},\r\n    \"sku\": {{$randomInt}},\r\n    \"description\": \"{{$randomLoremParagraph}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/products",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove the added product",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const prodSchema = JSON.parse(pm.collectionVariables.get(\"prodJsonSchema\"))\r",
											"pm.collectionVariables.set(\"prodCount\", pm.collectionVariables.get(\"prodCount\") - 1)\r",
											"const delProd = JSON.stringify(pm.response.json())\r",
											"const addedProd = pm.collectionVariables.get(\"addedProduct\")\r",
											"\r",
											"pm.test(\"Validating product's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(prodSchema)\r",
											"})\r",
											"\r",
											"pm.test(\"Responce should to contain deleted product\", () => {\r",
											"    pm.expect(delProd).to.eql(addedProd)\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products/{{addedProductId}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products",
										"{{addedProductId}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove the deleted product",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 200\", () => {\r",
											"    pm.response.to.have.status(200)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/products/{{addedProductId}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"products",
										"{{addedProductId}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create user with random properties for the negative delete cases",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const bithdayYears = [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004]\r",
											"const userLevels = [\"admin\", \"consumer\", \"lord\"]\r",
											"\r",
											"const randomBithdayYear = bithdayYears[Math.floor(Math.random() * bithdayYears.length)]\r",
											"const randomMon = Math.floor(Math.random() * 12)\r",
											"const randomDay = Math.floor(Math.random() * 28)\r",
											"\r",
											"const randLevel = userLevels[Math.floor(Math.random() * userLevels.length)]\r",
											"\r",
											"pm.variables.set(\"randomBithDate\", `${randomBithdayYear}-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randomSignUpDay\", `2022-${randomMon}-${randomDay}`)\r",
											"pm.variables.set(\"randUserLevel\", randLevel)\r",
											"\r",
											"const userSchema = {\r",
											"    \"type\": \"object\",\r",
											"    \"properties\": {\r",
											"        \"id\": { \r",
											"            \"type\": \"integer\",\r",
											"            \"minimum\": 1\r",
											"        },\r",
											"        \"firstName\": { \"type\": \"string\" },\r",
											"        \"LastName\": { \"type\": \"string\" },\r",
											"        \"email\": { \"type\": \"string\" },\r",
											"        \"dateOfBirth\": { \"type\": \"string\" },\r",
											"        \"emailVerified\": { \"type\": \"boolean\" },\r",
											"        \"signUpDate\": { \"type\": \"string\" },\r",
											"        \"status\": { \"type\": \"string\" },\r",
											"        \"level\": { \"type\": \"string\" }\r",
											"    },\r",
											"    \"require\": [\"id\", \"firstName\", \"lastName\", \"email\", \"dateOfBirth\", \"emailVerified\", \"signUpDate\", \"status\", \"level\"]\r",
											"}\r",
											"\r",
											"pm.collectionVariables.set(\"userJsonSchema\", JSON.stringify(userSchema))"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
											"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating users's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(userSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedUserId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedUser\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"firstName\": \"{{$randomFirstName}}\",\r\n    \"lastName\": \"{{$randomLastName}}\",\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"dateOfBirth\": \"{{randomBithDate}}\",\r\n    \"emailVerified\": {{$randomBoolean}},\r\n    \"signUpDate\": \"{{randomSignUpDay}}\",\r\n    \"status\": \"active\",\r\n    \"level\": \"{{randUserLevel}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/users",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove the added user",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = JSON.parse(pm.collectionVariables.get(\"userJsonSchema\"))\r",
											"pm.collectionVariables.set(\"userCount\", pm.collectionVariables.get(\"userCount\") - 1)\r",
											"const delUser = JSON.stringify(pm.response.json())\r",
											"const addedUser = pm.collectionVariables.get(\"addedUser\")\r",
											"\r",
											"pm.test(\"Validating user's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(userSchema)\r",
											"})\r",
											"\r",
											"pm.test(\"Responce should to contain deleted user\", () => {\r",
											"    pm.expect(delUser).to.eql(addedUser)\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users/{{addedUserId}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users",
										"{{addedUserId}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove the deleted user",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 200\", () => {\r",
											"    pm.response.to.have.status(200)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/users/{{addedUserId}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"users",
										"{{addedUserId}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create new order with random properties Copy",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const body = {\r",
											"    \"name\": 'orderForDelete',\r",
											"    \"sku\": parseInt(pm.variables.replaceIn('{{$randomInt}}'))\r",
											"}\r",
											"\r",
											"pm.variables.set(\"body\", JSON.stringify(body))\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
											"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") + 1)\r",
											"\r",
											"pm.test(\"Validating order's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(orderSchema)\r",
											"})\r",
											"\r",
											"pm.collectionVariables.set(\"addedOrderId\", pm.response.json().id)\r",
											"pm.collectionVariables.set(\"addedOrder\", pm.response.text())"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{body}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseUrl}}/orders",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove the added order Copy",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const orderSchema = JSON.parse(pm.collectionVariables.get(\"orderJsonSchema\"))\r",
											"pm.collectionVariables.set(\"orderCount\", pm.collectionVariables.get(\"orderCount\") - 1)\r",
											"const delOrder = JSON.stringify(pm.response.json())\r",
											"const addedOrder = pm.collectionVariables.get(\"addedOrder\")\r",
											"\r",
											"pm.test(\"Validating order's JSON schema\", () => {\r",
											"    pm.response.to.have.jsonSchema(orderSchema)\r",
											"})\r",
											"\r",
											"pm.test(\"Responce should to contain deleted order\", () => {\r",
											"    pm.expect(delOrder).to.eql(addedOrder)\r",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/orders/{{addedOrderId}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders",
										"{{addedOrderId}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Remove the added order Copy 2",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response code is 200\", () => {\r",
											"    pm.response.to.have.status(200)\r",
											"});\r",
											"\r",
											"pm.test(\"Content-Type is present\", () => {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"});\r",
											"\r",
											"pm.test('Content-Type is a application/json', () => {\r",
											"    const contentType = pm.response.headers.get('Content-Type')\r",
											"    pm.expect(contentType).to.contain('application/json', 'Content type is not \"application/json\"');\r",
											"});\r",
											"\r",
											"pm.test('Response body is empty', () => {\r",
											"    const respBody = pm.response.text()\r",
											"    pm.expect(respBody).to.eql('', \"Response has not error message\")\r",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/orders/{{addedOrderId}}",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"orders",
										"{{addedOrderId}}"
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Response time is less than 200ms\", () => {",
									"  pm.expect(pm.response.responseTime).to.be.below(200);",
									"});"
								]
							}
						}
					]
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "http://localhost:3000",
			"type": "string"
		},
		{
			"key": "prodPageSize",
			"value": "3",
			"type": "string"
		},
		{
			"key": "orderPageSize",
			"value": "3",
			"type": "string"
		},
		{
			"key": "userPageSize",
			"value": "5",
			"type": "string"
		},
		{
			"key": "addRandomProducts",
			"value": "10",
			"type": "string"
		},
		{
			"key": "prodCount",
			"value": "3"
		},
		{
			"key": "orderCount",
			"value": "3"
		},
		{
			"key": "userCount",
			"value": "9"
		},
		{
			"key": "prodPageCount",
			"value": "1"
		},
		{
			"key": "prodJsonSchema",
			"value": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": { \n            \"type\": \"number\",\n            \"minimum\": 1\n        },\n        \"name\": { \"type\": \"string\" },\n        \"price\": { \n            \"type\": \"number\",\n            \"minimum\": 1\n        },\n        \"sku\": { \"type\": \"number\" },\n        \"description\": { \"type\": \"string\" }\n    },\n    \"require\": [\"id\", \"name\", \"sku\", \"description\" ]\n}",
			"type": "string"
		},
		{
			"key": "prodListJsonSchema",
			"value": "{\n    \"type\": \"array\",\n    \"items\":{\n        \"type\": \"object\",\n        \"properties\": {\n            \"id\": { \n                \"type\": \"number\",\n                \"minimum\": 1\n            },\n            \"name\": { \"type\": \"string\" },\n            \"price\": { \n                \"type\": \"number\",\n                \"minimum\": 1\n            },\n            \"sku\": { \"type\": \"number\" },\n            \"description\": { \"type\": \"string\" }\n        },\n        \"require\": [\"id\", \"name\", \"sku\", \"description\" ]\n    }\n}",
			"type": "string"
		},
		{
			"key": "addedProduct",
			"value": ""
		},
		{
			"key": "upProd",
			"value": ""
		},
		{
			"key": "addedProductId",
			"value": ""
		},
		{
			"key": "sortProduct",
			"value": ""
		},
		{
			"key": "sortProductId",
			"value": ""
		},
		{
			"key": "userListJsonSchema",
			"value": "{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"integer\",\"minimum\":1},\"firstName\":{\"type\":\"string\"},\"LastName\":{\"type\":\"string\"},\"email\":{\"type\":\"string\"},\"dateOfBirth\":{\"type\":\"string\"},\"emailVerified\":{\"type\":\"boolean\"},\"signUpDate\":{\"type\":\"string\"},\"status\":{\"type\":\"string\"},\"level\":{\"type\":\"string\"}},\"require\":[\"id\",\"firstName\",\"lastName\",\"email\",\"dateOfBirth\",\"emailVerified\",\"signUpDate\",\"status\",\"level\"]}}"
		},
		{
			"key": "userJsonSchema",
			"value": "{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"integer\",\"minimum\":1},\"firstName\":{\"type\":\"string\"},\"LastName\":{\"type\":\"string\"},\"email\":{\"type\":\"string\"},\"dateOfBirth\":{\"type\":\"string\"},\"emailVerified\":{\"type\":\"boolean\"},\"signUpDate\":{\"type\":\"string\"},\"status\":{\"type\":\"string\"},\"level\":{\"type\":\"string\"}},\"require\":[\"id\",\"firstName\",\"lastName\",\"email\",\"dateOfBirth\",\"emailVerified\",\"signUpDate\",\"status\",\"level\"]}"
		},
		{
			"key": "addedUserId",
			"value": ""
		},
		{
			"key": "addedUser",
			"value": ""
		},
		{
			"key": "userPageCount",
			"value": ""
		},
		{
			"key": "upUser",
			"value": ""
		},
		{
			"key": "sortUserId",
			"value": ""
		},
		{
			"key": "sortUser",
			"value": ""
		},
		{
			"key": "orderListJsonSchema",
			"value": "{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"integer\",\"minimum\":1},\"name\":{\"type\":\"string\"},\"sku\":{\"type\":\"integer\"}},\"require\":[\"id\",\"name\",\"sku\"]}}"
		},
		{
			"key": "orderJsonSchema",
			"value": "{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"integer\",\"minimum\":1},\"name\":{\"type\":\"string\"},\"sku\":{\"type\":\"integer\"}},\"require\":[\"id\",\"name\",\"sku\"]}"
		},
		{
			"key": "addedOrderId",
			"value": ""
		},
		{
			"key": "addedOrder",
			"value": ""
		},
		{
			"key": "orderPageCount",
			"value": ""
		},
		{
			"key": "upOrder",
			"value": ""
		},
		{
			"key": "sortOrderId",
			"value": ""
		},
		{
			"key": "sortOrder",
			"value": ""
		},
		{
			"key": "randomProduct",
			"value": ""
		},
		{
			"key": "randomProdId",
			"value": ""
		},
		{
			"key": "randProdSku",
			"value": ""
		},
		{
			"key": "randOrderId",
			"value": ""
		},
		{
			"key": "randOrder",
			"value": ""
		},
		{
			"key": "minPriceProdId",
			"value": ""
		},
		{
			"key": "minPriceProd",
			"value": ""
		},
		{
			"key": "minProdSku",
			"value": ""
		},
		{
			"key": "minOrderId",
			"value": ""
		},
		{
			"key": "minOrder",
			"value": ""
		}
	]
}